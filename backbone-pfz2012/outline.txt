INTRO
=====

 * Klassieke website: database -> server applicatie -> client (browser)
 * Mettertijd: database -> server applicatie -> clients; RSS, browser, mobiel
 * Beter: database -> API -> server applicatie (html), alternatieve clients (mobiel), 3rd party
 * Nieuw: database -> API -> (web) client.
   * Geen server-side UI

 dwz: de server heeft alleen een API; de browserapplicatie is slechts één client van velen.

 Voordelen:
  * Eenvoudiger
    * Beheersbare entrypoints
  * Schaalbaarheid door eenvoud
  * Rapid application development
  * Client-onafhankelijk

Brug naar backbone: presentatie richt zich op de browser als client, als volledig zelfstandige applicatie die een API als datasource gebruikt.
Dit kan natuurlijk in 'vanilla' Javascript of, ivm browserverschillen, met JQuery.
Javascript of jQuery zijn echter libraries; ze dwingen van zichzelf weinig tot geen structuur af. Wat je nodig hebt is een applicatieframework; je wilt je applicatie op kunnen delen in componenten, structuur.

Introducing Backbone

BACKBONE
========

Backbone is een Javascript applicatieframework waarin je je client-applicatie kunt structureren.
Het is gebouwd bovenop jQuery/Zepto voor ajax & DOM manipulatie, en de Underscore.js toolkit library.

 Om te beginnen: je pagina renderen door een View. In Backbone definieer je een View als volgt:

var MyView = Backbone.view.extend({
	tagName: "strong",

	id: "hello-world",

	render: function() {
		this.$el.text("Hello world!");
	}
});

var main = new MyView();
main.render();
$("body").html(main.el);

Models
------

 Models en collections zijn in essentie datacontainers; get/set methodes, synchronisatiemogelijkheden, default waarden, datavalidatie, events, etc.


 * Als back-end van een model wordt standaard uitgegaan van een REST-ful webservice; GETs om op te halen, POSTS om op te slaan, PUTs om bij te werken, en DELETEs om te verwijderen.
 * Dit is echter relatief eenvoudig te vervangen door bijvoorbeeld LocalStorage, SOAP, of wat dan ook door de Backbone.sync methode te implementeren / overschrijven.

Model:

var MyModel = Backbone.model.extend({
	
});

meer nie.

var thing = new MyModel({message: "Hello world"});

var MyView = Backbone.view.extend({
	render: function() {
		this.$el.text(this.model.get("message"));
	}
});

var view = new MyView({model: thing});
view.render();


 -- event binding


var MyView = Backbone.view.extend({
	initialize: function() {
	  this.model.on("change", this.render);
	},

	render: function() {
	  this.$el.text(this.model.get("message"));
	}
});

var model = new MyModel();
var view = new MyView({model: model});
model.set("message", "Hello world!");

 * indien een veld van het model wijzigt word render() aangeroepen
 * geen expliciete aanroep naar render() - minder handwerk, minder code, minder koppeling



 -- Collections & Fetch()

 Collections zijn eigenlijk containers voor models; voegt logica toe om een lijst van models op te halen, en heeft collection-functies van Underscore 'ingemixed' (mixin), zoals find, filter, etc.


Backbone.view.extend({
  intitialize: function() {
    this.model.on("reset", this.render);
  }

	render: function() {
		this.model.each(function(todo) {
      this.$el.append(todo.get("message"));
		});
	}
});

 var Collection = Backbone.Collection.extend({
    model: MyModel,
 	url: "api/todos"
 });

 var todos = new Collection();
 var view = new MyView({model: todos});
 todos.fetch();

 * vuurt een request af (async)
 * model rendert als dat request afgerond & verwerkt is
 * View zal zichzelf ook opnieuw renderen als de data bijgewerkt wordt (door een 2e fetch, of bijv. door updates gepushed via websockets)

 Views zijn wrappers om de presentatie heen; je kunt ze programmeren om HTML te renderen wanneer er iets verandert aan een model (event binding), en declaratief events toe te voegen aan hetgeen ze renderen (onclick etc).

 -- Routers

 Routers zijn de componenten die structuur aan de front-end geven in de vorm van URLs. Backbone URLs zijn standaard geencodeerd in het Anchor-gedeelte van een url (bijvoorbeeld: http://site.com/index.html#todos/1), maar met de History API van HTML5 kun je ook 'native' URLs gebruiken: http://site.com/todos/1

 // vb 1: router met enkele router
 var Router = Backbone.Router.extend({
  routes: {
    "todos" : "listTodos"
  },

  listTodos: function() {
    var todos = new Collection();
    var view = new MyView({model: todos});
    $("body").html(view.el);
    todos.fetch();
  }
 });

 // vb 2: route met parameters
  var Router = Backbone.Router.extend({
  routes: {
    "todos" : "listTodos",
    "todo/:id" : "showTodo"
  },

  listTodos: function() { /* ... */ },

  showTodo: function(id) {
    var singleTodo = new Todo({id: id});
    var todoView = new TodoView({model: singleTodo});
    singleTodo.fetch();
  }
 });

// CUTOFF 1: demo applicatie!1one

Bij grotere views wordt de render functie snel groot. Bovendien is html in javascript genereren niet handig voor designers. Gelukkig zijn er ook goede template libraries die we kunnen gebruiken. Underscore biedt een standaard template functie. Mustache.js en varianten zijn veel gebruikt, Haml.js is ook mogelijk.

(misschien nog even tonen)
Backbone.view.extend({
  intitialize: function() {
    ..
  },

  template: "<ul>{{#todos}}<li>{{message}}</li>{{/todos}}</ul>",

  render: function() {
    var data = {todos: this.model.toJSON()};
    var output = Mustache.render(this.template, data);
    $(this.el).html(output);
  }
});



EXTRA
=====

 * Template libraries
 * Verdere structurering / modularisatie dmv Require.js
  * Requirejs + Handlebars/hbs + r.js optimizer = single page webapplicatie in drie bestanden: html (minimaal), css, js
 * (diepgaand / offtopic?) Server-side rendering voor 'first hit', search engines met bv node.js
 * unit tests met jasmine
 * functionele tests met fitnesse / selenium / hipper iets
 * Client web application build tools (yeoman & co, nooit echt ingedoken)