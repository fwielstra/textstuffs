Nieuwe outline

Key note prsentatie voor eerste stukje 'theorie'. TODO plaatje maken
Daarna livecoding met Chocolat
Verschillende fases in git via tags als backup

Voor de presentatie
We hebben drie librariies Zepto Underscore Backbone Even uitleggen wat die libraries zijn.
Zepto: vergelijkbaar met jquery, alleen selector
Underscoe: Utility belt
Backbone: De ruggegraat

We gaan live coden! Het resultaat staat in github, zodat je het later kunt terugzien.

We beginnen met een view
Een view is een component in backbone om gedrag en de weergave van elkaar te scheiden. Nog wat minder abstract: de html en de javascript voor event handling kunnen zo apart blijven.

Mijn collega freek maakt nu een view aan.
We gebruiken de extend functie. Extenden van een class in OO talen. Je kunt de bestaande view class uitbreiden met eigen functionaliteit.
Minimale wat je altijd moet doen: de render functie implmenteren/aanmaken.
... Coding
Het property el zoals je nu ziet krijg je automatisch in backbone. Vervolgens gebruiken zepto om het element met onze inhoud te vullen.

Nu gebeurt er nog niks, de render wordt nog niet aangeroepen. Dit kan alsvolgt: Laat eens zien Freek!
Freek maakt nu een instatie aan. en roept nu de render functie aan. Het element, bestaande uit html, wordt nu gegenereerd. Laatste stap is de gerenderde element in de pagina zetten.
Mogelijke vragen: $ teken is de syntax van zowel JQuery als Zepto (niet meteen vertellen)
	Dit lijkt omslachtig, maar als je grote applicaties hebt waar in 5 tot 10 mensen werken, dan is helpt je dit enorm om de applicatie onderhoudbaar te houden. Freek en ik werken in een team 10 mensen. Iedereen programmeert, maar niemand heeft zijn eigen stukje. (denk pas vertellen als iemand het echt vraagt).

Nog wat customazation. De Hello world wordt nu in een div gezet, dat doen backbone. Wat als we een strong element willen? Laat eens zien Freek!
... Coding
Classnames toevoegen kan ook...
En events.
... Coding

Dit waten dan de views. Nu de volgende stap, we gaan data in onze view zetten. Backbone biedt hiervoor de Model. Deze kun je ook extenden net als de view.
INTRO
=====

 * Klassieke website: database -> server applicatie -> client (browser)
 * Mettertijd: database -> server applicatie -> clients; RSS, browser, mobiel
 * Beter: database -> API -> server applicatie (html), alternatieve clients (mobiel), 3rd party
 * Nieuw: database -> API -> (web) client.
   * Geen server-side UI

 dwz: de server heeft alleen een API; de browserapplicatie is slechts één client van velen.

 Voordelen:
  * Eenvoudiger
    * Beheersbare entrypoints
  * Schaalbaarheid door eenvoud
  * Rapid application development
  * Client-onafhankelijk

Brug naar backbone: presentatie richt zich op de browser als client, als volledig zelfstandige applicatie die een API als datasource gebruikt.
Dit kan natuurlijk in 'vanilla' Javascript of, ivm browserverschillen, met JQuery.
Javascript of jQuery zijn echter libraries; ze dwingen van zichzelf weinig tot geen structuur af. Wat je nodig hebt is een applicatieframework; je wilt je applicatie op kunnen delen in componenten, structuur.

Introducing Backbone

BACKBONE
========

Backbone is een Javascript applicatieframework waarin je je client-applicatie kunt structureren.
Het is gebouwd bovenop jQuery/Zepto voor ajax & DOM manipulatie, en de Underscore.js toolkit library.

 Om te beginnen: je pagina renderen door een View. In Backbone definieer je een View als volgt:

var TodoView = Backbone.view.extend({
	tagName: "li",

	render: function() {
		this.$el.text("Talk to corporate"); // like a boss
	}
});

var main = new MyView();
main.render();
$("body").html(main.el);

Models
------

 Models en collections zijn in essentie datacontainers; get/set methodes, synchronisatiemogelijkheden, default waarden, datavalidatie, events, etc.


 * Als back-end van een model wordt standaard uitgegaan van een REST-ful webservice; GETs om op te halen, POSTS om op te slaan, PUTs om bij te werken, en DELETEs om te verwijderen.
 * Dit is echter relatief eenvoudig te vervangen door bijvoorbeeld LocalStorage, SOAP, of wat dan ook door de Backbone.sync methode te implementeren / overschrijven.

Model:

var TodoItem = Backbone.model.extend({
	
});

var promoteSynergy = new TodoItem({
  description: "Promote Syngergy" // like a boss
});

console.log(promoteSynergy.get("description"));
promoteSynergy.set("description", "Approve memos")
promoteSynergy.set({
  description : "Talk to corporate",
  priority: 1,
  done: true
});

var TodoItemView = Backbone.view.extend({
	render: function() {
		this.$el.text(this.model.get("description"));
	}
});

var view = new TodoItemView({
  model: doLaundry
});

view.render();


 -- event binding


var TodoItemView = Backbone.view.extend({
	initialize: function() {
	  this.model.on("change", this.render);
	},

	render: function() {
	  this.$el.text(this.model.get("description"));
	}
});

var todo = new TodoItem();
var view = new TodoItemView({model: model});
todo.set("description", "Direct workflow");

 * indien een veld van het model wijzigt word render() aangeroepen
 * geen expliciete aanroep naar render() - minder handwerk, minder code, minder koppeling



 -- Collections & Fetch()

 Collections zijn eigenlijk containers voor models; voegt logica toe om een lijst van models op te halen, en heeft collection-functies van Underscore 'ingemixed' (mixin), zoals find, filter, etc.


var TodosListView = Backbone.view.extend({
  intitialize: function() {
    this.model.on("reset", this.render);
  }

  render: function() {
    this.model.each(function(todo) {
      this.$el.append(todo.get("message"));
    });
  }
});

 var Todos = Backbone.Collection.extend({
  model: Todo,
  url: "api/todos"
 });

 var todos = new Todos();
 var listView = new TodosListView({model: todos});
 $("body").html(listView.el);
 todos.fetch();

 * vuurt een request af (async)
 * model rendert als dat request afgerond & verwerkt is
 * View zal zichzelf ook opnieuw renderen als de data bijgewerkt wordt (door een 2e fetch, of bijv. door updates gepushed via websockets)

 Views zijn wrappers om de presentatie heen; je kunt ze programmeren om HTML te renderen wanneer er iets verandert aan een model (event binding), en declaratief events toe te voegen aan hetgeen ze renderen (onclick etc).

 -- Routers

 Routers zijn de componenten die structuur aan de front-end geven in de vorm van URLs. Backbone URLs zijn standaard geencodeerd in het Anchor-gedeelte van een url (bijvoorbeeld: http://site.com/index.html#todos/1), maar met de History API van HTML5 kun je ook 'native' URLs gebruiken: http://site.com/todos/1

 // vb 1: router met enkele router
 var Router = Backbone.Router.extend({
  routes: {
    "todos" : "listTodos"
  },

  listTodos: function() {
    var todos = new Todos();
    var view = new TodosView({model: todos});
    $("body").html(view.el);
    todos.fetch();
  }
 });

 // vb 2: route met parameters
var Router = Backbone.Router.extend({
  routes: {
    "todos" : "listTodos",
    "todo/:id" : "showTodo"
  },

  listTodos: function() { /* ... */ },

  showTodo: function(id) {
    var singleTodo = new Todo({id: id});
    var todoView = new TodoView({model: singleTodo});
    singleTodo.fetch();
  }
});

// CUTOFF 1: demo applicatie!1one

Bij grotere views wordt de render functie snel groot. Bovendien is html in javascript genereren niet handig voor designers. Gelukkig zijn er ook goede template libraries die we kunnen gebruiken. Underscore biedt een standaard template functie. Mustache.js en varianten zijn veel gebruikt, Haml.js is ook mogelijk.

(misschien nog even tonen)

<script type="text/mustache" id="todo-list">
  <ul>
    {{#todos}}
      <li>{{message}} (like a boss)</li>
    {{/todos}}
  </ul>
</script>

var TodosView = Backbone.View.extend({

  template: $("#todo-list"),

  render: function() {
    var data = {todos: this.model.toJSON()};
    var output = Mustache.render(this.template, data);
    this.$el.html(output);
  }
});



EXTRA
=====

 * Template libraries
 * Verdere structurering / modularisatie dmv Require.js
  * Requirejs + Handlebars/hbs + r.js optimizer = single page webapplicatie in drie bestanden: html (minimaal), css, js
 * (diepgaand / offtopic?) Server-side rendering voor 'first hit', search engines met bv node.js
 * unit tests met jasmine
 * functionele tests met fitnesse / selenium / hipper iets
 * Client web application build tools (yeoman & co, nooit echt ingedoken)
