INTRO
=====

 * Klassieke website: database -> server applicatie -> client (browser)
 * Mettertijd: database -> server applicatie -> clients; RSS, browser, mobiel
 * Beter: database -> API -> server applicatie (html), alternatieve clients (mobiel)
 * Nieuw: database -> API -> client.

 dwz: de server heeft alleen een API; de browserapplicatie is slechts één client van velen.

 Voordelen:
  * Schaalbaarheid door eenvoud
  * Rapid application development
  * Snelle expansie (dwz: toevoegen van een client kan snel) (browser, mobiel, public API)
  * (optioneel indien toegestaan: voorbeeld NS aanhalen; applicatie bouwen op bestaande API binnen zes weken, prototype binnen een dag)

Brug naar backbone: presentatie richt zich op de browser als client, als volledig zelfstandige applicatie die een API als datasource gebruikt.
Dit kan natuurlijk in 'vanilla' Javascript of, ivm browserverschillen, met JQuery.
Echter: het structureren van een applicatie aan de clientside is tot recent niet heel veel aandacht aan besteed.
jQuery code heeft de neiging om er als volgt uit te zien:

 $.get('http://site.com/api/posts', function(posts) {
 	$.each(posts, function(post) {
 		$('#posts').append('<li>' + post + '</li>');
 	});
 });

Wat is hier mis mee? Model, view en controller allen in één. In 2005 kwam Ruby on Rails en werd het MVC paradigma behoorlijk snel een 'de factor' standaard voor het structureren van server-side applicaties, ook voor het grote publiek; deze gedachtengang ging echter niet over naar de front-end, voornamelijk omdat front-end code voornamelijk relatief kleine snippets waren; dropdown-effect hier, AJAX content verversen daar, etc.

Maar dat kan niet meer; gemiddelde website heeft duizenden regels JS die van alles doen en, als website een 'first-class' consumer van een API wordt, neemt deze code alleen maar toe.

Dus is er structuur nodig om een single-page webapplicatie te schrijven zonder om te komen in een gebrek aan structuur.

Introducing Backbone

BACKBONE
========

Backbone is een Javascript applicatieframework; geen MVC, maar volgens velen eerder een MVP framework. Er zijn geen controllers maar routers.

iig. In Backbone heb je een aantal basisconcepten:

 * Models
 * Collections (extends Model)
 * Views
 * Controllers

 Models en collections zijn in essentie datacontainers; get/set methodes, synchronisatiemogelijkheden, default waarden, datavalidatie, events, etc.

 Collections zijn essentieel containers voor models; voegt logica toe om een lijst van models op te halen, en heeft collection-functies van Underscore 'ingemixed' (mixin), zoals find, filter, etc.

 Views zijn wrappers om de presentatie heen; je kunt ze programmeren om HTML te renderen wanneer er iets verandert aan een model (event binding), en declaratief events toe te voegen aan hetgeen ze renderen (onclick etc).

 Controllers zijn hetgeen dat alles aan elkaar koppelt; je declareert 'clienside' routes (#/post/1) waarbij callbacks uitgevoerd worden indien die routes aangeroepen worden.

 Typisch gebruik van een Backbone applicatie: bij een route (#/posts) wordt een Collection aangemaakt (var posts = new Posts()), en een view (var postsView = new PostsView(posts)). De view geeft aan dat hij luistert naar een event binnen de collection. Vervolgens wordt er met de storage (server of wat dan ook, bv localstorage) gesynced dmv posts.fetch(); async request wordt afgevuurd, en wanneer data binnen komt wordt de postsView gerendered.

 TODO: bovenstaand vertalen naar code / door een voorbeeldapplicatie lopen.


EXTRA
=====

 * Template libraries
 * Verdere structurering / modularisatie dmv Require.js
  * Requirejs + Handlebars/hbs + r.js optimizer = single page webapplicatie in drie bestanden: html (minimaal), css, js
 * (diepgaand / offtopic?) Server-side rendering voor 'first hit', search engines met bv node.js
 * unit tests met jasmine
 * functionele tests met fitnesse / selenium / hipper iets
 * Client web application build tools (yeoman & co, nooit echt ingedoken)